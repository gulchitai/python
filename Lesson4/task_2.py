# 2. Написать два алгоритма нахождения i-го по счёту простого числа. Функция нахождения простого числа должна принимать
# на вход натуральное и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.
# Первый — с помощью алгоритма «Решето Эратосфена».
# Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков. Используйте этот код и попробуйте его
# улучшить/оптимизировать под задачу.
# Второй — без использования «Решета Эратосфена».
# Примечание. Вспомните классический способ проверки числа на простоту.

# Решето Эратосфена
def func_sieve(i):
    n = 5000
    sieve = [k for k in range(n)]
    sieve[1] = 0

    for k in range(2, n):
        if sieve[k] != 0:
            j = k * 2
            while j < n:
                sieve[j] = 0
                j += k

    result = [k for k in sieve if k != 0]
    return result[i-1]

#"import task_2" "task_2.func_sieve(100)"
#1000 loops, best of 5: 2.43 msec per loop

# скорость алгоритма не меняется с изменением i т.к. количество чисел в массиве всегда одинаковое


#################################################################################################
def prime(i):
    n = 1
    col = 0
    while True:
        n += 1
        d = 2
        while n % d != 0:
            d += 1
        if d == n:
            col += 1
        if col == i:
            return n

#"import task_2" "task_2.prime(10)"
#1000 loops, best of 5: 17.5 usec per loop

#"import task_2" "task_2.prime(100)"
#1000 loops, best of 5: 2.68 msec per loop

#"import task_2" "task_2.prime(150)"
#1000 loops, best of 5: 6.85 msec per loop

#print(func_sieve(100))



